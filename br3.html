<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Brick Breaking Game – Quest 3 with Velocity Curve</title>
    <!-- A-Frame and Physics -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@v3.3.0/dist/aframe-physics-system.min.js"></script>
    <script>
      // This component reads the change in the controller’s x position and applies
      // a non-linear curve so that fast movements produce larger displacements.
      AFRAME.registerComponent('paddle-from-controller', {
        schema: {
          paddle: { type: 'selector' },
          sensitivity: { default: 2.0 },
          curveFactor: { default: 1.5 }
        },
        init: function () {
          // Store the last frame’s controller position.
          this.lastControllerPos = new THREE.Vector3();
          this.lastControllerPos.copy(this.el.object3D.position);
        },
        tick: function () {
          var controllerPos = this.el.object3D.position;
          var dx = controllerPos.x - this.lastControllerPos.x;
          // Apply a non-linear velocity curve:
          var curvedDx = this.data.sensitivity *
                         Math.sign(dx) *
                         Math.pow(Math.abs(dx), this.data.curveFactor);
          var paddleEl = this.data.paddle;
          if (paddleEl) {
            var paddlePos = paddleEl.getAttribute('position');
            paddlePos.x += curvedDx;
            paddleEl.setAttribute('position', paddlePos);
          }
          this.lastControllerPos.copy(controllerPos);
        }
      });

      // Brick component: removes the brick when hit by the ball.
      AFRAME.registerComponent('brick', {
        init: function () {
          var el = this.el;
          el.addEventListener('collide', function (e) {
            if (e.detail.body.el && e.detail.body.el.id === 'ball') {
              el.parentNode.removeChild(el);
            }
          });
        }
      });

      // Generates a grid of bricks.
      AFRAME.registerComponent('brick-generator', {
        init: function () {
          var sceneEl = this.el;
          var rows = 3;
          var cols = 5;
          var startX = -1.5;
          var startY = 2;
          var brickWidth = 0.6;
          var brickHeight = 0.3;
          var brickDepth = 0.2;
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < cols; j++) {
              var brick = document.createElement('a-box');
              brick.setAttribute('position', {
                x: startX + j * (brickWidth + 0.1),
                y: startY - i * (brickHeight + 0.1),
                z: -3
              });
              brick.setAttribute('width', brickWidth);
              brick.setAttribute('height', brickHeight);
              brick.setAttribute('depth', brickDepth);
              brick.setAttribute('color', '#FFC65D');
              brick.setAttribute('static-body', '');
              brick.setAttribute('brick', '');
              sceneEl.appendChild(brick);
            }
          }
        }
      });

      // Ball reset & momentum-check component.
      // – If the ball falls (y < 0) it’s reset.
      // – If its speed drops below a threshold, we “nudge” it by resetting its velocity.
      AFRAME.registerComponent('ball-reset', {
        tick: function () {
          var pos = this.el.getAttribute('position');
          if (pos.y < 0) {
            this.resetBall();
          }
          if (this.el.body) {
            var vel = this.el.body.velocity;
            var speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y + vel.z * vel.z);
            if (speed < 0.5) {
              // Nudge the ball back to a healthy speed.
              this.el.body.velocity.set(0.5, 1.5, -1);
            }
          }
        },
        resetBall: function () {
          this.el.setAttribute('position', '0 1 -3');
          if (this.el.body) {
            this.el.body.velocity.set(0.5, 1.5, -1);
            this.el.body.angularVelocity.set(0, 0, 0);
          }
        }
      });
    </script>
  </head>
  <body>
    <a-scene physics="gravity: -9.8" brick-generator>
      <!-- Sky -->
      <a-sky color="#ECECEC"></a-sky>
      
      <!-- Invisible walls to keep the ball in play -->
      <a-box position="-2 1 -3" width="0.2" height="2" depth="10" static-body visible="false"></a-box>
      <a-box position="2 1 -3" width="0.2" height="2" depth="10" static-body visible="false"></a-box>
      <a-box position="0 2.5 -3" width="4" height="0.2" depth="10" static-body visible="false"></a-box>
      
      <!-- Paddle (moved via the controller) -->
      <a-box id="paddle" position="0 0.5 -3" width="1.5" height="0.2" depth="0.3" color="#0000FF" static-body></a-box>
      
      <!-- Ball with increased upward velocity -->
      <a-sphere id="ball" position="0 1 -3" radius="0.15" color="#FF0000"
                dynamic-body="shape: sphere; mass: 1; restitution: 0.9; linearDamping: 0; angularDamping: 0; velocity: 0.5 1.5 -1"
                ball-reset></a-sphere>
      
      <!-- Visual floor -->
      <a-plane position="0 0 -3" rotation="-90 0 0" width="4" height="10" color="#7BC8A4"></a-plane>
      
      <!-- Instruction text -->
      <a-text value="Brick Breaker: Use your right controller to move the paddle" position="-1 3 -3" color="#000"></a-text>
      
      <!-- Right controller (Quest 3) driving the paddle with a velocity curve -->
      <a-entity oculus-touch-controls="hand: right"
                paddle-from-controller="paddle: #paddle; sensitivity: 2.0; curveFactor: 1.5"></a-entity>
      
      <!-- Fallback camera with a mouse cursor -->
      <a-entity camera position="0 1.6 0">
        <a-entity cursor="fuse: false; rayOrigin: mouse"
                  geometry="primitive: ring; radiusInner: 0.02; radiusOuter: 0.03"
                  material="color: black; shader: flat"
                  position="0 0 -1">
        </a-entity>
      </a-entity>
    </a-scene>
  </body>
</html>
