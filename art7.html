<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>3D Art Museum – Paintings Only</title>
    <!-- Include A-Frame -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <style>
      body { margin: 0; }
      /* UI overlay for controls */
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(255,255,255,0.9);
        padding: 10px;
        border-radius: 5px;
        font-family: sans-serif;
      }
      #ui button, #ui select {
        margin: 5px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <!-- UI Controls -->
    <div id="ui">
      <button id="zoomIn">Zoom In</button>
      <button id="zoomOut">Zoom Out</button>
      <button id="nextArtwork">Next Painting</button>
      <br>
      <label for="resolution">Resolution:</label>
      <select id="resolution">
        <option value="native">Native</option>
        <option value="4k">4K</option>
        <option value="2k">2K</option>
      </select>
    </div>

    <!-- A-Frame Scene -->
    <a-scene>
      <!-- Camera (its z-position is modified for zooming) -->
      <a-camera id="camera" position="0 1.6 0"></a-camera>
      <!-- Artwork plane: its geometry will be updated dynamically -->
      <a-plane id="artwork" position="0 1.6 -3" width="3" height="2" color="#FFF"></a-plane>
      <!-- Text entity for artwork details -->
      <a-text id="info" value="Loading painting..." align="center" position="0 0.3 -3" width="4"></a-text>
      <a-sky color="#ECECEC"></a-sky>
    </a-scene>

    <script>
      // Global variables for caching artworks and texture handling.
      let cachedArtworks = [];
      let currentIndex = 0;
      let nativeImageUrl = "";

      /**
       * Fetch a random artwork from The Met API.
       * We use a wildcard search (q=*) and then check the returned object's classification.
       * Only objects with a primary image, dimensions, and a classification that includes "painting"
       * (case insensitive) are accepted.
       */
      function fetchRandomPaintingPromise(attempts = 5) {
        const searchURL = "https://collectionapi.metmuseum.org/public/collection/v1/search?hasImages=true&q=*";
        return fetch(searchURL)
          .then(response => response.json())
          .then(data => {
            if (!data.objectIDs || data.objectIDs.length === 0) {
              throw new Error("No artworks found.");
            }
            const randomId = data.objectIDs[Math.floor(Math.random() * data.objectIDs.length)];
            return fetch(`https://collectionapi.metmuseum.org/public/collection/v1/objects/${randomId}`);
          })
          .then(response => response.json())
          .then(artwork => {
            // Check that the artwork has a primary image, dimensions, and is classified as a painting.
            if (
              artwork.primaryImage && artwork.primaryImage !== "" &&
              artwork.dimensions &&
              artwork.classification &&
              artwork.classification.toLowerCase().includes("painting")
            ) {
              return {
                title: artwork.title || "N/A",
                artist: artwork.artistDisplayName || "N/A",
                dimensions: artwork.dimensions || "N/A",
                nativeImageUrl: artwork.primaryImage
              };
            } else {
              if (attempts <= 1) throw new Error("No valid painting found.");
              return fetchRandomPaintingPromise(attempts - 1);
            }
          });
      }

      // Prefetch a specified number of paintings and add them to the cache.
      function prefetchArtworks(count) {
        let promises = [];
        for (let i = 0; i < count; i++) {
          promises.push(fetchRandomPaintingPromise());
        }
        Promise.all(promises)
          .then(results => {
            cachedArtworks = cachedArtworks.concat(results);
            if (cachedArtworks.length && currentIndex === 0) {
              displayArtwork(cachedArtworks[currentIndex]);
            }
          })
          .catch(err => {
            console.error("Error prefetching artworks:", err);
            document.getElementById('info').setAttribute('value', 'Error prefetching paintings.');
          });
      }

      // Try to parse dimensions metadata (expects a string like "83.8 x 63.5 cm").
      // Returns an object with numeric width and height.
      function parseDimensions(dimStr) {
        const regex = /([\d\.]+)\s*[x×]\s*([\d\.]+)/;
        const match = dimStr.match(regex);
        if (match) {
          return {
            height: parseFloat(match[1]),
            width: parseFloat(match[2])
          };
        }
        return null;
      }

      // Update the artwork plane's geometry to maintain the correct aspect ratio.
      function updatePlaneGeometry(dimensionsMetadata) {
        let dims = parseDimensions(dimensionsMetadata);
        let artworkPlane = document.getElementById('artwork');
        if (dims) {
          let aspect = dims.width / dims.height; // aspect ratio = width/height
          let planeWidth, planeHeight;
          // For landscape paintings, fix width = 3 and compute height.
          if (aspect >= 1) {
            planeWidth = 3;
            planeHeight = planeWidth / aspect;
          } else {
            // For portrait paintings, fix height = 3 and compute width.
            planeHeight = 3;
            planeWidth = planeHeight * aspect;
          }
          artworkPlane.setAttribute('width', planeWidth);
          artworkPlane.setAttribute('height', planeHeight);
        } else {
          // Fallback dimensions if parsing fails.
          artworkPlane.setAttribute('width', 3);
          artworkPlane.setAttribute('height', 2);
        }
      }

      // Display the given painting from the cache.
      function displayArtwork(artwork) {
        nativeImageUrl = artwork.nativeImageUrl;
        document.getElementById('artwork').setAttribute('src', nativeImageUrl);
        const infoText = "Title: " + artwork.title +
                         "\nArtist: " + artwork.artist +
                         "\nDimensions: " + artwork.dimensions;
        document.getElementById('info').setAttribute('value', infoText);
        updatePlaneGeometry(artwork.dimensions);
      }

      // Prefetch an initial set of paintings.
      prefetchArtworks(3);

      // "Next Painting" button: cycle through cached paintings.
      document.getElementById('nextArtwork').addEventListener('click', function() {
        currentIndex = (currentIndex + 1) % cachedArtworks.length;
        displayArtwork(cachedArtworks[currentIndex]);
        // Prefetch more if nearing the end of the cache.
        if (cachedArtworks.length - currentIndex < 2) {
          prefetchArtworks(3);
        }
      });

      // Zoom controls.
      // "Zoom In" moves the camera back (increasing its z) so the painting appears larger.
      document.getElementById('zoomIn').addEventListener('click', function() {
        const camera = document.getElementById('camera');
        let pos = camera.getAttribute('position');
        pos.z += 0.5;
        camera.setAttribute('position', pos);
      });
      // "Zoom Out" moves the camera forward (decreasing its z) so the painting appears smaller.
      document.getElementById('zoomOut').addEventListener('click', function() {
        const camera = document.getElementById('camera');
        let pos = camera.getAttribute('position');
        pos.z -= 0.5;
        camera.setAttribute('position', pos);
      });

      // Generate a resized version of the image using an offscreen canvas.
      function generateResizedImage(url, targetWidth, callback) {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.onload = function() {
          const scale = targetWidth / img.width;
          const targetHeight = img.height * scale;
          const canvas = document.createElement('canvas');
          canvas.width = targetWidth;
          canvas.height = targetHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
          callback(canvas.toDataURL());
        };
        img.onerror = function() {
          console.error("Error loading image for resizing.");
          callback(null);
        };
        img.src = url;
      }

      // Resolution selection: update the artwork texture with a resized image.
      document.getElementById('resolution').addEventListener('change', function(e) {
        const bucket = e.target.value;
        if (bucket === "native") {
          document.getElementById('artwork').setAttribute('src', nativeImageUrl);
        } else if (bucket === "4k") {
          generateResizedImage(nativeImageUrl, 3840, function(dataUrl) {
            if (dataUrl) {
              document.getElementById('artwork').setAttribute('src', dataUrl);
            }
          });
        } else if (bucket === "2k") {
          generateResizedImage(nativeImageUrl, 2048, function(dataUrl) {
            if (dataUrl) {
              document.getElementById('artwork').setAttribute('src', dataUrl);
            }
          });
        }
      });
    </script>
  </body>
</html>
