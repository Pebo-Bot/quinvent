<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>3D Art Museum â€“ Paintings</title>
    <!-- Include A-Frame -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <style>
      body { margin: 0; }
      /* UI overlay for controls */
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(255,255,255,0.9);
        padding: 10px;
        border-radius: 5px;
        font-family: sans-serif;
      }
      #ui button, #ui select {
        margin: 5px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <!-- UI Controls -->
    <div id="ui">
      <button id="zoomIn">Zoom In</button>
      <button id="zoomOut">Zoom Out</button>
      <button id="nextArtwork">Next Artwork</button>
      <br>
      <label for="resolution">Resolution:</label>
      <select id="resolution">
        <option value="native">Native</option>
        <option value="4k">4K</option>
        <option value="2k">2K</option>
      </select>
    </div>

    <!-- A-Frame Scene -->
    <a-scene>
      <!-- A camera; note that we adjust its z-position to simulate zoom -->
      <a-camera id="camera" position="0 1.6 0"></a-camera>

      <!-- The artwork plane -->
      <a-plane id="artwork" position="0 1.6 -3" width="3" height="2" color="#FFF"></a-plane>

      <!-- Text for artwork details -->
      <a-text id="info" value="Loading artwork..." align="center" position="0 0.3 -3" width="4"></a-text>

      <a-sky color="#ECECEC"></a-sky>
    </a-scene>

    <script>
      // Global variables for caching and resolution handling.
      let cachedArtworks = []; // Array of artwork info objects.
      let currentIndex = 0;
      let nativeImageUrl = "";

      // Returns a promise that resolves to a valid painting artwork object
      // using The Met's Collection API.
      function fetchRandomPaintingPromise(attempts = 5) {
        return fetch("https://collectionapi.metmuseum.org/public/collection/v1/search?hasImages=true&q=paintings")
          .then(response => response.json())
          .then(data => {
            if (!data.objectIDs || data.objectIDs.length === 0)
              throw new Error("No paintings found.");
            const randomId = data.objectIDs[Math.floor(Math.random() * data.objectIDs.length)];
            return fetch(`https://collectionapi.metmuseum.org/public/collection/v1/objects/${randomId}`);
          })
          .then(response => response.json())
          .then(artwork => {
            if (artwork.primaryImage && artwork.primaryImage !== "" && artwork.dimensions) {
              return {
                title: artwork.title || "N/A",
                artist: artwork.artistDisplayName || "N/A",
                dimensions: artwork.dimensions || "N/A",
                nativeImageUrl: artwork.primaryImage
              };
            } else {
              if (attempts <= 1) throw new Error("No valid artwork found.");
              return fetchRandomPaintingPromise(attempts - 1);
            }
          });
      }

      // Prefetch a specified number of artworks and add them to the cache.
      function prefetchArtworks(count) {
        let promises = [];
        for (let i = 0; i < count; i++) {
          promises.push(fetchRandomPaintingPromise());
        }
        Promise.all(promises)
          .then(results => {
            cachedArtworks = cachedArtworks.concat(results);
            // If no artwork is displayed yet, show the first one.
            if (cachedArtworks.length && currentIndex === 0) {
              displayArtwork(cachedArtworks[currentIndex]);
            }
          })
          .catch(err => {
            console.error("Error prefetching artworks:", err);
          });
      }

      // Display a given artwork from the cache.
      function displayArtwork(artwork) {
        nativeImageUrl = artwork.nativeImageUrl;
        // Set the artwork texture to the native image initially.
        document.getElementById('artwork').setAttribute('src', nativeImageUrl);
        const infoText = "Title: " + artwork.title +
                         "\nArtist: " + artwork.artist +
                         "\nDimensions: " + artwork.dimensions;
        document.getElementById('info').setAttribute('value', infoText);
      }

      // Initial prefetch: cache 3 artworks.
      prefetchArtworks(3);

      // Next Artwork button: show the next cached artwork.
      document.getElementById('nextArtwork').addEventListener('click', function() {
        currentIndex++;
        if (currentIndex >= cachedArtworks.length) {
          currentIndex = 0;
        }
        displayArtwork(cachedArtworks[currentIndex]);
        // Refill the cache if needed.
        if (cachedArtworks.length - currentIndex < 2) {
          prefetchArtworks(3);
        }
      });

      // Zoom controls:
      // Note: In this scene the artwork is at z = -3.
      // To "zoom in" (get closer), we move the camera backward (decreasing its z value).
      // To "zoom out" (get farther), we move the camera forward (increasing its z value).
      document.getElementById('zoomIn').addEventListener('click', function() {
        const camera = document.getElementById('camera');
        let pos = camera.getAttribute('position');
        pos.z -= 0.5; // Move backward to get closer to the plane.
        camera.setAttribute('position', pos);
      });

      document.getElementById('zoomOut').addEventListener('click', function() {
        const camera = document.getElementById('camera');
        let pos = camera.getAttribute('position');
        pos.z += 0.5; // Move forward to get farther away.
        camera.setAttribute('position', pos);
      });

      // Generate a resized version of the image using an offscreen canvas.
      function generateResizedImage(url, targetWidth, callback) {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.onload = function() {
          const scale = targetWidth / img.width;
          const targetHeight = img.height * scale;
          const canvas = document.createElement('canvas');
          canvas.width = targetWidth;
          canvas.height = targetHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
          callback(canvas.toDataURL());
        };
        img.onerror = function() {
          console.error("Error loading image for resizing.");
          callback(null);
        };
        img.src = url;
      }

      // Resolution selection handler.
      document.getElementById('resolution').addEventListener('change', function(e) {
        const bucket = e.target.value;
        if (bucket === "native") {
          document.getElementById('artwork').setAttribute('src', nativeImageUrl);
        } else if (bucket === "4k") {
          // 3840px wide for 4K.
          generateResizedImage(nativeImageUrl, 3840, function(dataUrl) {
            if (dataUrl) {
              document.getElementById('artwork').setAttribute('src', dataUrl);
            }
          });
        } else if (bucket === "2k") {
          // 2048px wide for 2K.
          generateResizedImage(nativeImageUrl, 2048, function(dataUrl) {
            if (dataUrl) {
              document.getElementById('artwork').setAttribute('src', dataUrl);
            }
          });
        }
      });
    </script>
  </body>
</html>
