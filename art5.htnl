<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>3D Art Museum – Paintings</title>
    <!-- Include A-Frame -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <style>
      body { margin: 0; }
      /* UI overlay for controls */
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(255,255,255,0.9);
        padding: 10px;
        border-radius: 5px;
        font-family: sans-serif;
      }
      #ui button, #ui select {
        margin: 5px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <!-- UI Controls -->
    <div id="ui">
      <button id="zoomIn">Zoom In</button>
      <button id="zoomOut">Zoom Out</button>
      <button id="nextArtwork">Next Artwork</button>
      <br>
      <label for="resolution">Resolution:</label>
      <select id="resolution">
        <option value="native">Native</option>
        <option value="4k">4K</option>
        <option value="2k">2K</option>
      </select>
    </div>

    <!-- A-Frame Scene -->
    <a-scene>
      <!-- Camera (its z-position is modified for zooming) -->
      <a-camera id="camera" position="0 1.6 0"></a-camera>
      <!-- Artwork plane: its geometry will be updated dynamically -->
      <a-plane id="artwork" position="0 1.6 -3" width="3" height="2" color="#FFF"></a-plane>
      <!-- Text entity for artwork details -->
      <a-text id="info" value="Loading artwork..." align="center" position="0 0.3 -3" width="4"></a-text>
      <a-sky color="#ECECEC"></a-sky>
    </a-scene>

    <script>
      // Global variables for caching artworks and texture handling.
      let cachedArtworks = [];
      let currentIndex = 0;
      let nativeImageUrl = "";

      // Fetch a random painting (with image and dimensions) from The Met.
      function fetchRandomPaintingPromise(attempts = 5) {
        return fetch("https://collectionapi.metmuseum.org/public/collection/v1/search?hasImages=true&q=paintings")
          .then(response => response.json())
          .then(data => {
            if (!data.objectIDs || data.objectIDs.length === 0) {
              throw new Error("No paintings found.");
            }
            const randomId = data.objectIDs[Math.floor(Math.random() * data.objectIDs.length)];
            return fetch(`https://collectionapi.metmuseum.org/public/collection/v1/objects/${randomId}`);
          })
          .then(response => response.json())
          .then(artwork => {
            if (artwork.primaryImage && artwork.primaryImage !== "" && artwork.dimensions) {
              return {
                title: artwork.title || "N/A",
                artist: artwork.artistDisplayName || "N/A",
                dimensions: artwork.dimensions || "N/A",
                nativeImageUrl: artwork.primaryImage
              };
            } else {
              if (attempts <= 1) throw new Error("No valid artwork found.");
              return fetchRandomPaintingPromise(attempts - 1);
            }
          });
      }

      // Cache several artworks so that switching is immediate.
      function prefetchArtworks(count) {
        let promises = [];
        for (let i = 0; i < count; i++) {
          promises.push(fetchRandomPaintingPromise());
        }
        Promise.all(promises)
          .then(results => {
            cachedArtworks = cachedArtworks.concat(results);
            if (cachedArtworks.length && currentIndex === 0) {
              displayArtwork(cachedArtworks[currentIndex]);
            }
          })
          .catch(err => {
            console.error("Error prefetching artworks:", err);
          });
      }

      // Try to parse dimensions metadata (expects a string like "83.8 x 63.5 cm")
      function parseDimensions(dimStr) {
        const regex = /([\d\.]+)\s*[x×]\s*([\d\.]+)/;
        const match = dimStr.match(regex);
        if (match) {
          let val1 = parseFloat(match[1]);
          let val2 = parseFloat(match[2]);
          return { height: val1, width: val2 };
        }
        return null;
      }

      // Update the artwork plane's geometry to match the artwork's aspect ratio.
      function updatePlaneGeometry(dimensionsMetadata) {
        let dims = parseDimensions(dimensionsMetadata);
        let artworkPlane = document.getElementById('artwork');
        if (dims) {
          let aspect = dims.width / dims.height; // aspect ratio = width/height
          let planeWidth, planeHeight;
          // For landscape paintings, fix width = 3 and compute height.
          if (aspect >= 1) {
            planeWidth = 3;
            planeHeight = planeWidth / aspect;
          } else {
            // For portrait paintings, fix height = 3 and compute width.
            planeHeight = 3;
            planeWidth = planeHeight * aspect;
          }
          artworkPlane.setAttribute('width', planeWidth);
          artworkPlane.setAttribute('height', planeHeight);
        } else {
          // Fallback to default dimensions if parsing fails.
          artworkPlane.setAttribute('width', 3);
          artworkPlane.setAttribute('height', 2);
        }
      }

      // Display the given artwork from the cache.
      function displayArtwork(artwork) {
        nativeImageUrl = artwork.nativeImageUrl;
        // Set the artwork's texture to its native image.
        document.getElementById('artwork').setAttribute('src', nativeImageUrl);
        const infoText = "Title: " + artwork.title +
                         "\nArtist: " + artwork.artist +
                         "\nDimensions: " + artwork.dimensions;
        document.getElementById('info').setAttribute('value', infoText);
        updatePlaneGeometry(artwork.dimensions);
      }

      // Prefetch an initial set of artworks.
      prefetchArtworks(3);

      // "Next Artwork" button: cycle through cached artworks.
      document.getElementById('nextArtwork').addEventListener('click', function() {
        currentIndex = (currentIndex + 1) % cachedArtworks.length;
        displayArtwork(cachedArtworks[currentIndex]);
        if (cachedArtworks.length - currentIndex < 2) {
          prefetchArtworks(3);
        }
      });

      // Zoom controls.
      // "Zoom In" moves the camera back (increasing its z) so the painting appears larger.
      // "Zoom Out" moves the camera forward (decreasing its z) so it appears smaller.
      document.getElementById('zoomIn').addEventListener('click', function() {
        const camera = document.getElementById('camera');
        let pos = camera.getAttribute('position');
        pos.z += 0.5;
        camera.setAttribute('position', pos);
      });
      document.getElementById('zoomOut').addEventListener('click', function() {
        const camera = document.getElementById('camera');
        let pos = camera.getAttribute('position');
        pos.z -= 0.5;
        camera.setAttribute('position', pos);
      });

      // Generates a resized image using an offscreen canvas.
      function generateResizedImage(url, targetWidth, callback) {
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.onload = function() {
          const scale = targetWidth / img.width;
          const targetHeight = img.height * scale;
          const canvas = document.createElement('canvas');
          canvas.width = targetWidth;
          canvas.height = targetHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
          callback(canvas.toDataURL());
        };
        img.onerror = function() {
          console.error("Error loading image for resizing.");
          callback(null);
        };
        img.src = url;
      }

      // Resolution selection: update the artwork texture with a resized image.
      document.getElementById('resolution').addEventListener('change', function(e) {
        const bucket = e.target.value;
        if (bucket === "native") {
          document.getElementById('artwork').setAttribute('src', nativeImageUrl);
        } else if (bucket === "4k") {
          generateResizedImage(nativeImageUrl, 3840, function(dataUrl) {
            if (dataUrl) {
              document.getElementById('artwork').setAttribute('src', dataUrl);
            }
          });
        } else if (bucket === "2k") {
          generateResizedImage(nativeImageUrl, 2048, function(dataUrl) {
            if (dataUrl) {
              document.getElementById('artwork').setAttribute('src', dataUrl);
            }
          });
        }
      });
    </script>
  </body>
</html>
